# .bashrc

#####################
# ❰❰ Environment ❱❱ #
#####################

# Append to path, without duplicates
pathadd() {
    if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
        PATH="${PATH:+"$PATH:"}$1"
    fi
}

# Additional runtime config
[[ -f /etc/bashrc ]] && source /etc/bashrc          # Global bashrc
[[ -f ~/.bashrc_style ]] && source ~/.bashrc_style  # Prompt & command colorization
[[ -f ~/.bashrc_extra ]] && source ~/.bashrc_extra  # Machine-specific config
[[ -f ~/.proxy ]] && source ~/.proxy                # Proxy settings
which virtualenvwrapper.sh > /dev/null 2>&1 && source $(which virtualenvwrapper.sh)

# Support bash_history across multiple terminals
export HISTFILESIZE=20000
export HISTSIZE=10000
export HISTCONTROL=ignoredups:erasedups
shopt -s histappend

# Paths
pathadd ~/.local/bin
pathadd ~/bin
pathadd ~/scripts
# export JRE_HOME=/opt/jdk1.8.0_51/jre
# export JAVA_HOME=/opt/jdk1.8.0_51
export DOTFILES=~/dotfiles
[ -z "$DOTFILES_EXTRA" ] && export DOTFILES_EXTRA=~/dotfiles_extra
export WORKSPACE=~/workspace


#########################
# ❰❰ General Aliases ❱❱ #
#########################

bak() { cp "$1"{,.bak}; }                                   # Copy to file.bak
alias cw='cd $WORKSPACE'
fd() { find ${2:-.} -name "$1" -prune -type d; }            # Recursive search (lit, dirs)
ff() { find ${2:-.} -name "$1" -type f; }                   # Recursive search (lit, files)
ge() { env | grep ${1:-""}; }                               # Search environment variables
gr() { grep -r "$1" ${2:-.}; }                              # Recursive search
hist-frequency() {                                          # Most frequently used commands
    history | awk '{a[$2]++}END{for(i in a){print a[i] " " i}}' | sort -rn | less
}
alias ll='ls -Alhv --group-directories-first'
lt() { tree $@ | color-filesize; }                          # Colored folder tree
lt2() { tree -L 2 $@ | color-filesize; }                    # Colored folder tree (depth 2)
md() { mkdir -p "$@" && cd "$@"; }                          # Create a dir and enter it
newest() {                                                  # Find most recent file w/ pattern
    find ${2:-.} -type f -name $1 -print0 | xargs -0 ls -t | head -n1
}
nullify() { "$@" >/dev/null 2>&1; }                         # Run cmd with no output
pwd-base() { basename $(pwd); }                             # Base name of the current working dir
alias pwd-src="pwd-base | sed 's/-/_/g'"                    # Guess name of project src dir
alias tailf='tail -f -n 50'
alias tree='tree -CAFah --du --dirsfirst --prune -I "*.sw*|.git|__pycache__"'
wcr() { gr "$1" $2 | wc -l; }                               # Recursive word count

# Misc Shortcuts
alias devterm='terminator -mfl 6-split &'
alias retroterm='/usr/local/src/retro-term/cool-retro-term &'
alias jj='jupyter notebook --port 9468 &'
alias jl='jupyter notebook list'
alias jq='pkill jupyter'
alias top='htop'
alias tt='tig'
alias weather='date;curl -4 http://wttr.in'

# Encryption
alias gen-aes='openssl enc -aes-256-cbc -P -md sha512'
alias gen-rsa='ssh-keygen -t rsa -b 4096'

# AWS CLI
s3cat() { aws s3 cp s3://$@ -; }
s3ls() { aws s3 ls s3://$@; }
s3rm() { aws s3 rm s3://$@; }


#################
# ❰❰ Network ❱❱ #
#################

alias listen='lsof -P -i -n | grcat conf.nmap'
alias local-ip='(ifconfig | awk "/inet/ { print $2 } " | sed -e s/addr://)'
alias public-ip='curl v4.ifconfig.co'
alias netconn='netstat -pan --inet'
alias unproxy='unset http_proxy https_proxy ftp_proxy no_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY'
alias tracert='traceroute'

# Mount a network share (remote_share, local_mountpoint, creds_file)
mount-share(){
    if ! mountpoint $2 > /dev/null 2>&1; then
        sudo mkdir -p $2
        sudo mount -v -t cifs -o credentials=$3 $1 $2
    else
        echo 'Already mounted'
    fi
}


#####################
# ❰❰ System Info ❱❱ #
#####################

alias df='df -khT | color-filesize'                         # Readable disk usage
alias du='du -Sh | sort -hr | color-filesize | more'        # Recursive folder size
distinfo() { cat /etc/os-release; lsb_release -a; }         # Distribution info
alias lu='column -ts: /etc/passwd | sort'                   # Formatted local user list
alias lu-current='w -hs | cut -d " " -f1 | sort | uniq'     # Currently logged on users
alias path='echo -e ${PATH//:/\\n}  | lc-gradient --seed=8' # List/format items on PATH
alias psu='ps -u $USER -o pid,%cpu,%mem,bsdtime,command'    # List user processes

# Combined system information
sysinfo() {
    echo -e "\n${RED}Host information:$NOCOLOR " ; uname -a | lc-gradient -S 60
    echo -e "\n${RED}Distro information:$NOCOLOR " ; distinfo | lc-gradient -S 60
    echo -e "\n${RED}Users logged on:$NOCOLOR " ; lu-current | lc-gradient -S 60
    echo -e "\n${RED}Current date :$NOCOLOR " ; date | lc-gradient -S 60
    echo -e "\n${RED}Machine stats :$NOCOLOR " ; uptime | lc-gradient -S 60
    echo -e "\n${RED}Memory stats :$NOCOLOR " ; free | lc-gradient -S 60
    echo -e "\n${RED}Diskspace :$NOCOLOR " ; df
    echo -e "\n${RED}Local IP Address :$NOCOLOR" ; my-ip | lc-gradient -S 60
    echo -e "\n${RED}Open connections :$NOCOLOR "; netconn;
    echo
}


##################
# ❰❰ Services ❱❱ #
##################

# Postgres
alias pg-start='sudo service postgresql-9.6 start'
alias pg-stop='sudo service postgresql-9.6 stop'
alias pg-restart='sudo service postgresql-9.6 restart'
alias psql='PAGER=$PG_PAGER LESS=$PG_LESS psql'


#######################
# ❰❰ Configuration ❱❱ #
#######################

# Commonly used config files
BASH_CONF="$DOTFILES/bash/bashrc"
BASH_CONF_ALL="$DOTFILES/bash/bashrc* $DOTFILES_EXTRA/bash/bashrc*"
GIT_CONF="$DOTFILES/git/gitconfig"
PG_CONF="$DOTFILES/postgres/psqlrc ~/.auth/pgpass"
SETUP_CONF="$DOTFILES/Makefile $DOTFILES_EXTRA/Makefile"
SSH_CONF="$DOTFILES_EXTRA/ssh/config"
VIM_CONF="$DOTFILES/vim/vimrc"
VIM_CONF_ALL="$VIM_CONF $DOTFILES/vim/README.md"

# Editor shortcuts
alias sb='echo "reloading bashrc..." | lolcat; source $BASH_CONF'
alias vb='vim $BASH_CONF'
alias vbb='vim -O2 $BASH_CONF_ALL'
alias vg='vim $GIT_CONF'
alias vv='vim $VIM_CONF'
alias vvv='vim -O2 $VIM_CONF_ALL'
alias vc='vim -O2 $BASH_CONF_ALL $VIM_CONF_ALL $GIT_CONF $PG_CONF $SSH_CONF $SETUP_CONF'

# Append a line to crontab, excluding duplicates
crontab-append() {
    if ! [[ $(crontab -l) =~ "$1" ]]; then
        (crontab -l 2>/dev/null; echo "$1") | crontab -
        echo "Updated crontab:"
    else
        echo "Already in crontab:"
    fi
    crontab -l
}


#############
# ❰❰ Git ❱❱ #
#############

GLOG_FORMAT='%C(blue)%h  %C(cyan)%ad  %C(reset)%s%C(green)  [%cn] %C(yellow)%d'
alias gp='git pull'
alias gs='git status'
alias gss='git status --short'
alias gc='git commit --verbose'
alias gcm='git commit -m'
alias gf='git fetch origin master:master'
alias gmend='git commit --amend'
alias grevise='git add --all; git commit --amend --no-edit'
alias gpatch='git add --patch'
alias gunstage='git reset HEAD'
alias guncommit='git reset --soft HEAD~1'
alias glog='git log --pretty=format:"$GLOG_FORMAT" --decorate --date=short'
alias glog-branch='glog master..HEAD'
alias glog-remote='gf; glog HEAD..origin/master'
alias glol='glog | lc-gradient-delay'
alias grebase='gf; git rebase --interactive master'
alias grebase-upstream='git fetch upstream; git rebase --interactive upstream/master'
alias gcontinue='git rebase --continue'
alias gcstat='git shortlog --summary --numbered'
alias gcstat-all='git rev-list --count HEAD'
alias groot='cd $(git rev-parse --show-toplevel)'
gadd() { git add ${@:-.}; }
ggr() { git grep "$1" ${2:-.}; }
grm(){ rm $1; git rm $1; }

# Pull if repo is alredy cloned, otherwise clone
gpclone() {
    repo_dir=${2:-$(basename $1)}
    echo $repo_dir
    if [ -d "$repo_dir" ]; then
        git -C $repo_dir pull
    else
        git clone $1 $repo_dir
    fi
}

# Delete local and remote branch
grm-branch() {
    read -p "Deleting branch $1. Continue?" -n 1 -r CONFIRM; echo
    if [[ $CONFIRM =~ ^[Yy]$ ]]; then
        git branch -d $1
        git push origin --delete $1
    fi
}
type -a __git_complete > /dev/null 2>&1 && __git_complete git-delete-branch _git_branch


################
# ❰❰ Python ❱❱ #
################

alias pipr='pip install -Ur requirements.txt | lc-gradient --seed=100'
alias in-env='python -c "import sys; sys.exit(0 if hasattr(sys, \"real_prefix\") else 1)"'
alias lsv='lsvirtualenv -b'
update-python() {
    make -C $DOTFILES update-python | lc-gradient
    make -C $DOTFILES_EXTRA update-python | lc-gradient
}

# Pytest shortcut, if not already defined
type -a pt > /dev/null 2>&1 || pt() { py-cleanup; py.test ${1:-./test}; }

# New virtual environment, with paths and packages
mkv() {
    mkvirtualenv -a . ${1:-$(pwd-base)}
    add2virtualenv .
    pipr
}

# Clean up leftover junk
py-cleanup() {
    find ${1:-.} -name "*.pyc" -type f -delete
    find ${1:-.} -name "__pycache__" -prune -type d -exec rm -rf '{}' \; 2> /dev/null
}
vim-cleanup() {
    find ${1:-.} -name "*.sw[mnop]" -type f -delete
}

# Run py.test with ludicrous verbosity
ptv(){
    py-cleanup
    py.test -vvv -rwrs --capture=no --full-trace ${1:-./test}
}

# Generate HTML py.test coverage report
ptc() {
    py-cleanup
    py.test --junit-xml=test-reports/py.test-latest.xml --cov ${1:-$(pwd-src)} --cov-report html ./test
    [[ -f htmlcov/index.html ]] && firefox htmlcov/index.html &
}

# Print source path of a python module
pyfile() {
    python -c "import $@; print $@.__file__" | sed 's/\.pyc/\.py/'
}
alias pf='pyfile'

# Open source file of a python module
vpyfile() {
    pf_path=$(pyfile $@)
    [[ -f $pf_path ]] && vim $pf_path
}
alias vp='vpyfile'

# Workon & cd/deactivate a virtualenv (with autocomplete)
wo() {
    if [ -n "$1" ]; then
        workon $1
        export _VIRT_ENV_PREV_PWD=$PWD
        cd $WORKSPACE/$1
    else
        deactivate
        cd $_VIRT_ENV_PREV_PWD
    fi
}
complete -o default -o nospace -F _virtualenvs wo


#########################
# ❰❰ File Operations ❱❱ #
#########################

# Verbose copy w/progress
cpv() {
    rsync -WavP --human-readable --progress $1 $2;
}

# Formatted preview for CSV files
csv-preview(){
    sed 's/,,/, ,/g;s/,,/, ,/g' "$@" | column -s, -t | less -#2 -N -S
}

# Recursive find/replace
grepsed() {
    FILE_COUNT=$(wcr $1 $3)
    if [ $FILE_COUNT -gt 0 ]; then
       read -p "Replacing $FILE_COUNT occurances of '$1' with '$2' Continue?" -n 1 -r CONFIRM; echo
       if [[ $CONFIRM =~ ^[Yy]$ ]]; then
            grep -rl "$1" ${3:-.} | xargs sed -i "s/$1/$2/g"
       fi
    else
        echo "No occurances of '$1' found"
    fi
}

# Recursive find/delete files
rrm() {
    num_files=$(find ${2:-.} -name "$1" -type f | wc -l)
    read -p "Deleting $num_files files. Continue?" -n 1 -r CONFIRM; echo
    if [[ $CONFIRM =~ ^[Yy]$ ]]; then
        find ${2:-.} -name "$1" -type f -delete
    fi
}

# Recursive find/delete directories
rrmdir() {
    num_dirs=$(find ${2:-.} -name "$1" -type d | wc -l)
    read -p "Deleting $num_dirs dirs. Continue?" -n 1 -r CONFIRM; echo
    if [[ $CONFIRM =~ ^[Yy]$ ]]; then
        find ${2:-.} -name "$1" -type d -exec rm -rf '{}' \;
    fi
}

# Create an archive (*.tar.gz) from given directory
maketar() {
    tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"
}

# Create a ZIP archive of a file or folder.
makezip() {
    zip -r "${1%%/}.zip" "$1"
}

# Mutli-format extract function
extract() {
    [ ! -f $1 ] && echo "$1 is not a valid file" && return 1
    case $1 in
        *.tar.bz2)   tar xvjf $1     ;;
        *.tar.gz)    tar xvzf $1     ;;
        *.bz2)       bunzip2 $1      ;;
        *.rar)       unrar x $1      ;;
        *.gz)        gunzip $1       ;;
        *.tar)       tar xvf $1      ;;
        *.tbz2)      tar xvjf $1     ;;
        *.tgz)       tar xvzf $1     ;;
        *.zip)       unzip $1        ;;
        *.Z)         uncompress $1   ;;
        *.7z)        7z x $1         ;;
        *)           echo "unsupported archive format" ;;
    esac
}

# Swap two files
swap() {
    # Neither file exists (or were not specified)
    [ $# -ne 2 ] && return 1
    [ -e $1 -o -e $2 ] || return 1

    # Only one file exists
    [ ! -e $1 ] && mv "$2" "$1" && return 0
    [ ! -e $2 ] && mv "$1" "$2" && return 0

    # Both files exist
    local TMPFILE=tmp.$$
    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}

# Enable Terminator to execute startup commands and keep shell open
[[ $TERM_START_CMD ]] && { eval "$TERM_START_CMD"; }
