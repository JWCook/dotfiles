# .bashrc

# Append to path, without duplicates
pathadd() {
    if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
        PATH="${PATH:+"$PATH:"}$1"
    fi
}

# Additional runtime config
[[ -f /etc/bashrc ]] && source /etc/bashrc
[[ -f ~/.bashrc_style ]] && source ~/.bashrc_style  # Prompt & command colorization
[[ -f ~/.bashrc_extra ]] && source ~/.bashrc_extra  # Machine/employer-specific config
which virtualenvwrapper.sh  > /dev/null 2>&1 && source $(which virtualenvwrapper.sh)


###############################
# ❰❰ Environment Variables ❱❱ #
###############################

# Support bash_history across multiple terminals
export HISTFILESIZE=20000
export HISTSIZE=10000
export HISTCONTROL=ignoredups:erasedups
shopt -s histappend

# Paths
pathadd ~/bin
pathadd ~/scripts
# export JRE_HOME=/opt/jdk1.8.0_51/jre
# export JAVA_HOME=/opt/jdk1.8.0_51
export DOTFILES=~/dotfiles
export DOTFILES_EXTRA=~/dotfiles_extra
export WORKSPACE=~/workspace

# Proxy
# export http_proxy=
# export https_proxy=
# export no_proxy=localhost,127.0.0.1


#################
# ❰❰ Aliases ❱❱ #
#################

# General Bash
function cpv() { rsync -WavP --human-readable --progress $1 $2; }   # Verbose copy w/progress
alias cw='cd $WORKSPACE'
alias df='df -khT | color-filesize'                                 # Readable disk usage
alias du='du -Sh | sort -hr | color-filesize | more'                # Recursive folder size
function fd() { find ${2:-.} -name "$1" -type d; }                  # Recursive search (lit, dirs)
function ff() { find ${2:-.} -name "$1" -type f; }                  # Recursive search (lit, files)
function gr() { grep -r "$1" ${2:-.}; }                             # Recursive search
alias list-users='column -ts: /etc/passwd | sort'
alias list-users-current='w -hs | cut -d " " -f1 | sort | uniq'
alias ll='ls -Alhv --group-directories-first'
function lt() { tree $@ | color-filesize; }                         # Colored folder tree
function lt2() { tree -L 2 $@ | color-filesize; }                   # Colored folder tree (depth 2)
function md() { mkdir -p "$@" && cd "$@"; }                         # Create a dir and enter it
alias netconn='netstat -pan --inet'
alias path='echo -e ${PATH//:/\\n}  | lc-gradient --seed=8'
alias psu='ps -u $USER -o pid,%cpu,%mem,bsdtime,command'
alias tailf='tail -f -n 50'
alias top='htop'
alias tracert='traceroute'
alias tree='tree -CAFah --du --dirsfirst --prune -I ".git|__pycache__"'
function wcr() { gr "$1" $2 | wc -l; }                              # Recursive word count

# Config
alias sb='echo "reloading bashrc..." | lolcat; source ~/.bashrc'
alias vb='vim -O2 $DOTFILES/bash/bashrc* $DOTFILES_EXTRA/bash/bashrc*'
alias vv='vim -O2 $DOTFILES/vim/vimrc $DOTFILES/vim/README.md'
alias vc='vim -O2 $DOTFILES/bash/bashrc* $DOTFILES_EXTRA/bash/bashrc* $DOTFILES/vim/vimrc $DOTFILES/git/gitconfig $DOTFILES/postgres/psqlrc $DOTFILES_EXTRA/ssh/config $DOTFILES/Makefile $DOTFILES_EXTRA/Makefile'
alias vp='vpyfile'

# Git
GLOG_FORMAT='%C(blue)%h  %C(cyan)%ad  %C(reset)%s%C(green)  [%cn] %C(yellow)%d'
alias gp='git pull'
alias gs='git status'
alias gss='git status --short'
alias gc='git commit --verbose'
alias gcm='git commit -m'
function ggr() { git grep "$1" ${2:-.}; }
alias gunstage='git reset HEAD'
alias guncommit='git reset --soft HEAD~1'
alias glog='git log --pretty=format:"$GLOG_FORMAT" --decorate --date=short'
# alias glog='git log --oneline --graph --no-merges'
alias glog-branch='glog master..HEAD'
alias grebase='git rebase --interactive master'
alias gstat='git shortlog --summary --numbered'
function grm(){ rm $1; git rm $1; }
# Delete local and remote branch
function grm-branch() {
    read -p "Deleting branch $1. Continue?" -n 1 -r CONFIRM; echo
    if [[ $CONFIRM =~ ^[Yy]$ ]]; then
        git branch -d $1; git push origin --delete $1;
    fi
}
type -a __git_complete > /dev/null 2>&1 && __git_complete git-delete-branch _git_branch

# Misc Shortcuts
alias devterm='terminator -mfl 6-split &'
alias retroterm='/usr/local/src/retro-term/cool-retro-term &'
alias tt='tig'
alias my-ip='(/sbin/ifconfig em1 | awk "/inet/ { print $2 } " | sed -e s/addr://)'

# Postgres
alias pg-start='sudo service postgresql-9.5 start'
alias pg-stop='sudo service postgresql-9.5 stop'
alias pg-restart='sudo service postgresql-9.5 restart'
alias psql='PAGER=$PG_PAGER LESS=$PG_LESS psql'

# Python
type -a pt > /dev/null 2>&1 && function pt(){ py-cleanup; py.test ${1:-./test}; }
function ptv(){ py-cleanup; py.test -vvs -rwrs ${1:-./test}; }
alias in-env='python -c "import sys; sys.exit(0 if hasattr(sys, \"real_prefix\") else 1)"'
alias lsv='lsvirtualenv -b'
alias mkv='mkvirtualenv -a . -r ./requirements.txt'
alias pipr='pip install -U pip -r requirements.txt | lc-gradient --seed=100'
alias py-cleanup='find . -name "*.pyc" -type f -delete;\
                  find . -name "__pycache__" -type d -exec rm -rf '{}' \; 2> /dev/null'
# Print source path of a python module
function pyfile() { python -c "import $@; print $@.__file__" | sed 's/\.pyc/\.py/'; }
# Open source file of a python module
function vpyfile() { pf_path=$(pyfile $@); [[ -f $pf_path ]] && vim $pf_path; }
# Workon & cd to a virtualenv (with autocomplete)
function wo() {
    if [ -n "$1" ]; then
        workon $1
        export _VIRT_ENV_PREV_PWD=$PWD
        cd $WORKSPACE/$1
    else
        deactivate
        cd $_VIRT_ENV_PREV_PWD
    fi
}
complete -o default -o nospace -F _virtualenvs wo

# AWS
function s3cat() { aws s3 cp s3://$@ -; }
function s3ls() { aws s3 ls s3://$@; }
function s3rm() { aws s3 rm s3://$@; }

#################################
# ❰❰ Miscellaneous Functions ❱❱ #
#################################

function csvpreview(){ sed 's/,,/, ,/g;s/,,/, ,/g' "$@" | column -s, -t | less -#2 -N -S; }
function nullify() { "$@" >/dev/null 2>&1; }

# Recursive find/replace
function grepsed() {
    read -p "Replacing $(wcr $1 $3) occurances of '$1' with '$2' Continue?" -n 1 -r CONFIRM; echo
    if [[ $CONFIRM =~ ^[Yy]$ ]]; then
        grep -rl "$1" ${3:-.} | xargs sed -i "s/$1/$2/g"
    fi
}

# Recursive find/delete files
function rrm() {
    num_files=$(find ${2:-.} -name "$1" -type f | wc -l)
    read -p "Deleting $num_files files. Continue?" -n 1 -r CONFIRM; echo
    if [[ $CONFIRM =~ ^[Yy]$ ]]; then
        find ${2:-.} -name "$1" -type f -delete
    fi
}

# Recursive find/delete directories
function rrmdir() {
    num_dirs=$(find ${2:-.} -name "$1" -type d | wc -l)
    read -p "Deleting $num_dirs dirs. Continue?" -n 1 -r CONFIRM; echo
    if [[ $CONFIRM =~ ^[Yy]$ ]]; then
        find ${2:-.} -name "$1" -type d -exec rm -rf '{}' \;
    fi
}

# Create an archive (*.tar.gz) from given directory
function maketar() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/" ; }

# Create a ZIP archive of a file or folder.
function makezip() { zip -r "${1%%/}.zip" "$1" ; }

# Mutli-format extract function
function extract() {
    [ ! -f $1 ] && echo "$1 is not a valid file" && return 1
    case $1 in
        *.tar.bz2)   tar xvjf $1     ;;
        *.tar.gz)    tar xvzf $1     ;;
        *.bz2)       bunzip2 $1      ;;
        *.rar)       unrar x $1      ;;
        *.gz)        gunzip $1       ;;
        *.tar)       tar xvf $1      ;;
        *.tbz2)      tar xvjf $1     ;;
        *.tgz)       tar xvzf $1     ;;
        *.zip)       unzip $1        ;;
        *.Z)         uncompress $1   ;;
        *.7z)        7z x $1         ;;
        *)           echo "unsupported archive format" ;;
    esac
}

# Swap two files
function swap() {
    # Neither file exists (or were not specified)
    [ $# -ne 2 ] && return 1
    [ -e $1 -o -e $2 ] || return 1

    # Only one file exists
    [ ! -e $1 ] && mv "$2" "$1" && return 0
    [ ! -e $2 ] && mv "$1" "$2" && return 0

    # Both files exist
    local TMPFILE=tmp.$$
    mv "$1" $TMPFILE
    mv "$2" "$1"
    mv $TMPFILE "$2"
}

# Print various pieces of system information
function sysinfo() {
    echo -e "\n${RED}Host information:$NOCOLOR " ; uname -a | lc-gradient -S 60
    echo -e "\n${RED}Distro information:$NOCOLOR " ; cat /etc/os-release | lc-gradient -S 60 ; lsb_release -a | lc-gradient -S 60
    echo -e "\n${RED}Users logged on:$NOCOLOR " ; list-users-current | lc-gradient -S 60
    echo -e "\n${RED}Current date :$NOCOLOR " ; date | lc-gradient -S 60
    echo -e "\n${RED}Machine stats :$NOCOLOR " ; uptime | lc-gradient -S 60
    echo -e "\n${RED}Memory stats :$NOCOLOR " ; free | lc-gradient -S 60
    echo -e "\n${RED}Diskspace :$NOCOLOR " ; df
    echo -e "\n${RED}Local IP Address :$NOCOLOR" ; my-ip | lc-gradient -S 60
    echo -e "\n${RED}Open connections :$NOCOLOR "; netconn;
    echo
}

# Enable Terminator to execute startup commands and keep shell open
[[ $TERM_START_CMD ]] && { eval "$TERM_START_CMD"; }
