\set PROMPT1 '%[%033[33;1m%]%x%[%033[0m%]%[%033[0;32;29m%]❰%n%[%033[0;36;0m%]@%[%033[0;32;29m%]%~❱ %[%033[0m%]%R%# '
\pset null ¤
\pset linestyle unicode
\pset border 2
\pset pager always
\timing
\set VERBOSITY verbose
\set HISTFILE ~/.psql_history- :DBNAME
\set HISTCONTROL ignoredups
\set COMP_KEYWORD_CASE upper

\set triggers 'SELECT * from pg_trigger WHERE NOT tgisinternal;'

\set kill_idle 'SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity WHERE state LIKE \'idle%\';'
\set kill_api 'SELECT pid, pg_terminate_backend(pid) FROM pg_stat_activity WHERE usename = \'api_user\';'

\set stat 'SELECT pid, usename, state, query FROM pg_stat_activity;'

\set waits 'SELECT pg_stat_activity.pid, pg_stat_activity.query, pg_stat_activity.waiting, now() - pg_stat_activity.query_start  as "totaltime", pg_stat_activity.backend_start FROM pg_stat_activity WHERE pg_stat_activity.query !~ \'%IDLE%\'::text AND pg_stat_activity.waiting = true;;'

\set locks 'SELECT a.pid,l.mode,a.query FROM pg_locks l,pg_stat_activity a WHERE l.granted=false and l.locktype=\'transactionid\' and l.pid=a.pid order by a.pid,l.granted;;'

\set blocked 'SELECT blocked_locks.pid AS blocked_pid, blocked_activity.usename AS blocked_user, blocking_locks.pid AS blocking_pid, blocking_activity.usename AS blocking_user, blocked_activity.query AS blocked_statement, blocking_activity.query AS current_statement_in_blocking_process FROM pg_locks blocked_locks JOIN pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid JOIN pg_locks blocking_locks ON blocking_locks.locktype = blocked_locks.locktype AND NOT blocking_locks.database IS DISTINCT FROM blocked_locks.database AND NOT blocking_locks.relation IS DISTINCT FROM blocked_locks.relation AND NOT blocking_locks.page IS DISTINCT FROM blocked_locks.page AND NOT blocking_locks.tuple IS DISTINCT FROM blocked_locks.tuple AND NOT blocking_locks.virtualxid IS DISTINCT FROM blocked_locks.virtualxid AND NOT blocking_locks.transactionid IS DISTINCT FROM blocked_locks.transactionid AND NOT blocking_locks.classid IS DISTINCT FROM blocked_locks.classid AND NOT blocking_locks.objid IS DISTINCT FROM blocked_locks.objid AND NOT  blocking_locks.objsubid IS DISTINCT FROM blocked_locks.objsubid AND blocking_locks.pid <> blocked_locks.pid JOIN pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid WHERE NOT blocked_locks.granted;'

\set ext 'SELECT * FROM pg_available_extensions ORDER BY name;'

\set disk 'SELECT d.datname AS Name,  pg_catalog.pg_get_userbyid(d.datdba) AS Owner, CASE WHEN pg_catalog.has_database_privilege(d.datname, \'CONNECT\') THEN pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(d.datname)) ELSE \'No Access\' END AS SIZE FROM pg_catalog.pg_database d ORDER BY CASE WHEN pg_catalog.has_database_privilege(d.datname, \'CONNECT\') THEN pg_catalog.pg_database_size(d.datname) ELSE NULL END DESC LIMIT 20;'

\set tablestat 'SELECT schemaname as schema, c.relname as table, c.reltuples::int as rows, c.relpages as pages, pg_size_pretty(pg_total_relation_size(relid)) AS total_size, seq_scan, seq_tup_read, idx_scan, idx_tup_fetch, n_tup_ins as tup_ins, n_tup_upd as tup_upd, n_tup_hot_upd as hot_upd, n_tup_del as tup_del, n_live_tup as live_tup, n_dead_tup as dead_tup, n_mod_since_analyze as mod_since_analyze, last_vacuum::date, last_autovacuum::date, last_analyze::date, last_autoanalyze::date, vacuum_count as vaccum_ct, autovacuum_count as autovacuum_ct, analyze_count as analyze_ct, autoanalyze_count as autoanalyze_ct FROM pg_stat_user_tables JOIN pg_class c ON c.oid = pg_stat_user_tables.relid WHERE schemaname <> \'pg_temp_3\' ORDER BY schema, c.relname;'

\set lgtables 'SELECT nspname AS schema, relname AS table, pg_size_pretty(pg_total_relation_size(C.oid)) AS total_size FROM pg_class C LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace) WHERE nspname NOT IN (\'pg_catalog\', \'information_schema\') AND C.relkind = \'r\' AND nspname !~ \'^pg_toast\' AND pg_total_relation_size(C.oid) > 100000000 ORDER BY pg_total_relation_size(C.oid) DESC;'

\set ixsummary 'SELECT n.nspname AS schema, c.relname AS table, c.reltuples::int AS rows, c.relpages AS pages, (SELECT pg_size_pretty(SUM(ix_sz)) FROM (SELECT pg_relation_size(idx.indexrelid) AS ix_sz FROM pg_stat_user_indexes idx WHERE idx.relid=x.indrelid) AS ix_szs) AS total_index_size, CASE WHEN x.is_unique = 1 THEN \'Y\' ELSE \'N\' END AS unique, COUNT(x2.indexname) AS number_of_indexes, SUM(CASE WHEN x2.number_of_columns = 1 THEN 1 ELSE 0 END) AS single_column, SUM(CASE WHEN x2.number_of_columns IS NULL THEN 0 WHEN x2.number_of_columns = 1 THEN 0 ELSE 1 END) AS multi_column FROM pg_namespace n LEFT OUTER JOIN pg_class c ON n.oid = c.relnamespace LEFT OUTER JOIN (SELECT indrelid, MAX(CAST(indisunique AS INTEGER)) AS is_unique FROM pg_index GROUP BY indrelid) x ON c.oid = x.indrelid LEFT OUTER JOIN (SELECT ic1.relname AS ctablename, ic2.relname AS indexname, ix.indnatts AS number_of_columns FROM pg_index ix JOIN pg_class ic1 ON ic1.oid = ix.indrelid JOIN pg_class ic2 ON ic2.oid = ix.indexrelid) AS x2 ON c.relname = x2.ctablename WHERE c.relkind = \'r\' AND n.nspname NOT IN (\'pg_catalog\', \'information_schema\', \'pg_temp_3\') GROUP BY schema, relname, reltuples, relpages, x.indrelid, x.is_unique ORDER BY schema, relname;'

\set ixsummary2 'SELECT n.nspname AS schema, c.relname AS table, c.reltuples::int AS rows, c.relpages AS pages, pg_size_pretty(pg_total_relation_size(ut.relid)) AS total_table_size, (SELECT pg_size_pretty(SUM(ix_sz)) FROM (SELECT pg_relation_size(idx.indexrelid) AS ix_sz FROM pg_stat_user_indexes idx WHERE idx.relid=x.indrelid) AS ix_szs) AS total_index_size, CASE WHEN x.is_unique = 1 THEN \'Y\' ELSE \'N\' END AS unique, COUNT(x2.indexname) AS number_of_indexes, SUM(CASE WHEN x2.number_of_columns = 1 THEN 1 ELSE 0 END) AS single_column, SUM(CASE WHEN x2.number_of_columns IS NULL THEN 0 WHEN x2.number_of_columns = 1 THEN 0 ELSE 1 END) AS multi_column, ut.last_analyze::date FROM pg_namespace n LEFT OUTER JOIN pg_class c ON n.oid = c.relnamespace LEFT OUTER JOIN pg_stat_user_tables ut ON ut.relid = c.oid LEFT OUTER JOIN (SELECT indrelid, MAX(CAST(indisunique AS INTEGER)) AS is_unique FROM pg_index GROUP BY indrelid) x ON c.oid = x.indrelid LEFT OUTER JOIN (SELECT ic1.relname AS ctablename, ic2.relname AS indexname, ix.indnatts AS number_of_columns FROM pg_index ix JOIN pg_class ic1 ON ic1.oid = ix.indrelid JOIN pg_class ic2 ON ic2.oid = ix.indexrelid) AS x2 ON c.relname = x2.ctablename WHERE c.relkind = \'r\' AND n.nspname NOT IN (\'public\', \'pg_catalog\', \'information_schema\', \'pg_temp_3\') GROUP BY n.nspname, c.relname, c.reltuples, c.relpages, ut.relid, ut.last_analyze, x.indrelid, x.is_unique ORDER BY n.nspname, c.relname;'

\set ixstat 'SELECT N.nspname AS schema, idx.relname AS table, idx.indexrelname AS index, CASE WHEN x.indisunique is true THEN \'Y\' ELSE \'N\' END AS unique, pg_size_pretty(pg_relation_size(idx.indexrelid)) AS index_size, idx.idx_scan AS scanned, idx.idx_tup_read AS read, idx.idx_tup_fetch AS fetched FROM pg_stat_user_indexes idx JOIN pg_index x ON x.indexrelid = idx.indexrelid JOIN pg_class c ON c.relname = idx.relname LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace) ORDER BY N.nspname, idx.relname, idx.indexrelname;'

\set lgindexes 'SELECT N.nspname AS schema, idx.relname AS table, idx.indexrelname AS index, CASE WHEN x.indisunique is true THEN \'Y\' ELSE \'N\' END AS unique, pg_size_pretty(pg_relation_size(N.nspname || \'.\' || idx.indexrelname)) AS index_size, idx.idx_scan AS scanned, idx.idx_tup_read AS read, idx.idx_tup_fetch AS fetched FROM pg_stat_user_indexes idx JOIN pg_index x ON x.indexrelid = idx.indexrelid JOIN pg_class C ON C.relname = idx.relname LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace) WHERE N.nspname NOT IN (\'pg_catalog\', \'information_schema\', \'pg_temp_3\') AND pg_relation_size(N.nspname || \'.\' || idx.indexrelname) > 100000000 ORDER BY pg_relation_size(N.nspname || \'.\' || idx.indexrelname) DESC;'

\set validate_promote 'SELECT n.nspname AS schema, c.relname AS table, c.reltuples::int AS rows, c.relpages AS pages, pg_size_pretty(pg_total_relation_size(ut.relid)) AS total_table_size, (SELECT pg_size_pretty(SUM(ix_sz)) FROM (SELECT pg_relation_size(idx.indexrelid) AS ix_sz FROM pg_stat_user_indexes idx WHERE idx.relid=x.indrelid) AS ix_szs) AS total_index_size, CASE WHEN x.is_unique = 1 THEN \'Y\' ELSE \'N\' END AS unique, COUNT(x2.indexname) AS number_of_indexes, SUM(CASE WHEN x2.number_of_columns = 1 THEN 1 ELSE 0 END) AS single_column, SUM(CASE WHEN x2.number_of_columns IS NULL THEN 0 WHEN x2.number_of_columns = 1 THEN 0 ELSE 1 END) AS multi_column, ut.last_analyze::date FROM pg_namespace n LEFT OUTER JOIN pg_class c ON n.oid = c.relnamespace LEFT OUTER JOIN pg_stat_user_tables ut ON ut.relid = c.oid LEFT OUTER JOIN (SELECT indrelid, MAX(CAST(indisunique AS INTEGER)) AS is_unique FROM pg_index GROUP BY indrelid) x ON c.oid = x.indrelid LEFT OUTER JOIN (SELECT ic1.relname AS ctablename, ic2.relname AS indexname, ix.indnatts AS number_of_columns FROM pg_index ix JOIN pg_class ic1 ON ic1.oid = ix.indrelid JOIN pg_class ic2 ON ic2.oid = ix.indexrelid) AS x2 ON c.relname = x2.ctablename WHERE c.relkind = \'r\' AND n.nspname = \'scratch\' GROUP BY n.nspname, c.relname, c.reltuples, c.relpages, ut.relid, ut.last_analyze, x.indrelid, x.is_unique ORDER BY n.nspname, c.relname; SELECT n.nspname AS schema, c.relname AS table, c.reltuples::int AS rows, c.relpages AS pages, pg_size_pretty(pg_total_relation_size(ut.relid)) AS total_table_size, (SELECT pg_size_pretty(SUM(ix_sz)) FROM (SELECT pg_relation_size(idx.indexrelid) AS ix_sz FROM pg_stat_user_indexes idx WHERE idx.relid=x.indrelid) AS ix_szs) AS total_index_size, CASE WHEN x.is_unique = 1 THEN \'Y\' ELSE \'N\' END AS unique, COUNT(x2.indexname) AS number_of_indexes, SUM(CASE WHEN x2.number_of_columns = 1 THEN 1 ELSE 0 END) AS single_column, SUM(CASE WHEN x2.number_of_columns IS NULL THEN 0 WHEN x2.number_of_columns = 1 THEN 0 ELSE 1 END) AS multi_column, ut.last_analyze::date FROM pg_namespace n LEFT OUTER JOIN pg_class c ON n.oid = c.relnamespace LEFT OUTER JOIN pg_stat_user_tables ut ON ut.relid = c.oid LEFT OUTER JOIN (SELECT indrelid, MAX(CAST(indisunique AS INTEGER)) AS is_unique FROM pg_index GROUP BY indrelid) x ON c.oid = x.indrelid LEFT OUTER JOIN (SELECT ic1.relname AS ctablename, ic2.relname AS indexname, ix.indnatts AS number_of_columns FROM pg_index ix JOIN pg_class ic1 ON ic1.oid = ix.indrelid JOIN pg_class ic2 ON ic2.oid = ix.indexrelid) AS x2 ON c.relname = x2.ctablename WHERE c.relkind = \'r\' AND n.nspname = \'derived\' GROUP BY n.nspname, c.relname, c.reltuples, c.relpages, ut.relid, ut.last_analyze, x.indrelid, x.is_unique ORDER BY n.nspname, c.relname;'

\set bloat 'SELECT schemaname AS schema, tablename AS table, reltuples::bigint, relpages::bigint, otta, ROUND((CASE WHEN otta=0 THEN 0.0 ELSE sml.relpages::FLOAT/otta END)::NUMERIC,1) AS tbloat, CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END AS wastedbytes, iname, ituples::bigint, ipages::bigint, iotta, ROUND((CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages::FLOAT/iotta END)::NUMERIC,1) AS ibloat, CASE WHEN ipages < iotta THEN 0 ELSE bs*(ipages-iotta) END AS wastedibytes FROM ( SELECT schemaname, tablename, cc.reltuples, cc.relpages, bs, CEIL((cc.reltuples*((datahdr+ma- (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::FLOAT)) AS otta, COALESCE(c2.relname,\'?\') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages, COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::FLOAT)),0) AS iotta FROM ( SELECT ma,bs,schemaname,tablename, (datawidth+(hdr+ma-(CASE WHEN hdr%ma=0 THEN ma ELSE hdr%ma END)))::NUMERIC AS datahdr, (maxfracsum*(nullhdr+ma-(CASE WHEN nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2 FROM ( SELECT schemaname, tablename, hdr, ma, bs, SUM((1-null_frac)*avg_width) AS datawidth, MAX(null_frac) AS maxfracsum, hdr+( SELECT 1+COUNT(*)/8 FROM pg_stats s2 WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename) AS nullhdr FROM pg_stats s, ( SELECT (SELECT current_setting(\'block_size\')::NUMERIC) AS bs, CASE WHEN SUBSTRING(v,12,3) IN (\'8.0\',\'8.1\',\'8.2\') THEN 27 ELSE 23 END AS hdr, CASE WHEN v ~ \'mingw32\' THEN 8 ELSE 4 END AS ma FROM (SELECT version() AS v) AS foo ) AS constants GROUP BY 1,2,3,4,5 ) AS foo ) AS rs JOIN pg_class cc ON cc.relname = rs.tablename JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname AND nn.nspname NOT IN (\'pg_catalog\', \'information_schema\') LEFT JOIN pg_index i ON indrelid = cc.oid LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid ) AS sml ORDER BY wastedbytes DESC;'

